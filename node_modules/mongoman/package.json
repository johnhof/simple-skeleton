{
  "name": "mongoman",
  "author": {
    "name": "John Hofrichter",
    "email": "https://github.com/johnhof"
  },
  "description": "MongoDB management utility",
  "version": "1.4.0",
  "repository": {
    "type": "git",
    "url": "git://github.com/johnhof/mongoman"
  },
  "main": "lib/mongoman.js",
  "keywords": [
    "schema",
    "validation",
    "mongo",
    "mongodb",
    "mongoose",
    "mongoman",
    "mongomanjs"
  ],
  "engines": {
    "node": ">=0.8.0"
  },
  "dependencies": {
    "fs": "0.0.2",
    "lodash": "2.4.x",
    "mongoose": "3.8.x"
  },
  "scripts": {
    "test": "mocha"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "https://github.com/johnhof/mongoman/blob/master/LICENSE-MIT"
    }
  ],
  "devDependencies": {
    "should": "1.1.x",
    "bcrypt-nodejs": "0.0.x",
    "chai": "1.10.x",
    "mocha": "1.21.x",
    "async": "0.2.5"
  },
  "readme": "Mongoman\n========\n\n[![Build Status](https://travis-ci.org/johnhof/mongoman.svg)](https://travis-ci.org/johnhof/mongoman)\n\nA node utility to simplify schema and model management. Most utility is wrapped around the [mongoose module](http://mongoosejs.com/index.html). If you would like to use mongoman as a replacement for mongoose, mongoose is aliased at both `mon.mongoose` and `mon.goose`\n\n# Key\n\n- [Usage](#usage)\n- [Property Builder](#property-builder)\n    - [Universal](#universal)\n        - [`prop.set(key, value)`](#propsetkey-value)\n        - [`prop.validate(errorMsg, valFunction)`](#propvalidateerrormsg-valfunction)\n        - [`prop.index(key|value, [value])`](#propindexkeyvalue-value)\n    - [Types](#types)\n        - [`prop.string()`](#propstring)\n        - [`prop.date()`](#propdate)\n        - [`prop.number()`](#propnumber)\n        - [`prop.buffer()`](#propbuffer)\n        - [`prop.mixed()`](#propmixed)\n        - [`prop.objectId()`](#propobjectid)\n        - [`prop.array()`](#proparray)\n        - [`prop.schema()`](#propschemaref-type)\n    - [Middleware](#middleware)\n        - [Shared](#shared)\n            - [`prop.onGet(function)`](#propongetfunction)\n            - [`prop.onSet(function)`](#proponsetfunction)\n        - [Date](#date)\n            - [`expires(dateTime)`](#propexpiresdateTime)\n        - [String](#string)\n            - [`prop.toUppercase()`](#proptouppercase)\n            - [`prop.toLowercase()`](#proptolowercase)\n            - [`prop.trim()`](#proptrim)\n    - [Validation](#validation)\n        - [Shared](#shared)\n            - [`prop.required()`](#proprequired)\n            - [`prop.default(value)`](#propdefaultvalue)\n            - [`prop.select([value])`](#propselectvalue)\n            - [`prop.enum(values, [message])`](#propenumvalues-message)\n            - [`prop.unique([bool])`](#propuniquebool)\n            - [`prop.ref(model)`](#proprefmodel)\n            - [`prop.min(value, [message])`](#propminvalue-message)\n            - [`prop.max(value, [message])`](#propmaxvalue-message)\n            - [`prop.length(value)`](#proplengthvalue-message)\n        - [Arrays](#arrays)\n            - [`prop.sparse([enables])`](#propsparseenabled)\n        - [Strings](#strings)\n            - [`prop.alphanum([message])`](#propalphanummessage)\n            - [`prop.regex(expression, [message])`](#propregexexpression-message)\n            - [`prop.email([message])`](#propemailmessage)\n            - [`prop.token([message])`](#proptokenmessage)\n            - [`prop.guid([message])`](#propguidmessage)\n            - [`prop.hostname([message])`](#prophostnamemessage)\n            - [`prop.url([message])`](#propurlmessage)\n            - [`prop.uppercase([message])`](#propuppercasemessage)\n            - [`prop.lowercase([message])`](#proplowercasemessage)\n        - [Numbers](#numbers)\n            - [`prop.greater(limit, [message])`](#propgreaterlimit-message)\n            - [`prop.less(limit, [message])`](#proplesslimit-message)\n            - [`prop.integer([message])`](#propintegermessage)\n- [Utilities](#utilities)\n    - [`mon.drop(collection)`](#mondropcollection)\n    - [`mon.connect([options])`](#monconnectoptions)\n    - [`mon.schema(schema)`](#monschemaschema)\n    - [`mon.model(modelName)`](#monmodelmodelname)\n    - [`mon.new(modelName)`](#monnewmodelname)\n    - [`mon.register(schema, [options])`](#monregisterschema-options)\n    - [`mon.registerAll(directory, [regex])`](#monregisteralldirectory-regex)\n- [Tests](#running-unit-tests)\n\n\n\n\n\n\n\n# Usage\n\n\n  `npm install mongoman`\n\n  leverage mongoman to cut down on bloat in model creation. For example, this\n\n  ```javascript\n  var mongoose = require('mongoose');\n\n  var newSchema = new mongoose.Schema({\n    email : {\n      type       : String,\n      required   : true,\n      validation : [{\n        msg       : 'invalid email',\n        validator : function (value) {\n          return /^([a-zA-Z0-9_\\-\\.]+)@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.)|(([a-zA-Z0-9\\-]+\\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\\]?)$/.test(value);\n        }\n      }]\n    password : {\n      type       : String,\n      required   : true,\n      validation : [{\n        msg       : 'too short',\n        validator : function (value) {\n          return value.length >= 6\n        }\n      }]\n    }\n  });\n\n  mongoose.model('ExampleModel', newSchema);\n  ```\n\n  becomes this\n\n  ```javascript\n  var mon = require('mongoman');\n\n  mon.register('ExampleModel', {\n    email    : mon().string().required().email().fin(),\n    password : mon().string().required().min(6).fin()\n  });\n```\n\nThe focus of mongoman is to simplify validation and schema creation. However, I do recommed looking at the [utilities](#utilities) section for some helpful utilities.\n\n\n\n\n# Property Builder\n\n\n\n\n\n\n\nThe core use of mongoman is schema creation via property building. To make a new schema, simply use the property builder chain, initiated with `mongoman()` and terminated with `fin()`. For example. a simple user schema might look something like this\n\n```javascript\nmon = require('mongoman');\n\nvar user = {\n\n  // validates the name to be a required string that fits the regex\n  name : mon().string().required().regex(/[a-z]+\\s*[a-z+]/i).fin(),\n\n  // sets the registered propert to default tothe current date-time\n  registered : mon().date().default(new Date()).fin(),\n\n  // validates the age to be a required integer of at least 18\n  age : mon().required().number().integer.min(18).fin()\n\n}\n```\n\nEvery validation middleware function has a default error, but errors can be augmented to inlude a property name by passing in a value to the `mon()` function call.\n\n``` javascript\nmon().email().fin(); // validation error : 'invalid email'\nmon('My email').email().fin(); // validation error : 'My email is not a valid email'\n```\n\n## Universal\n\nIf a property or validation isn't included as a supported chainable function, you can easily include it using the following functions.\n\n### `prop.set(key, value)`\n\nSet the key/value passed in for the property\n\n```javascript\n  schema.newProp = mon().set('type', String).fin();\n```\n\n### `prop.validate(errorMsg, valFunction)`\n\nBind the validation function to the property, throwing the error message if it returns false\n\n```javascript\n  function isOdd (value) {\n    return (value % 2) == 1\n  }\n\n  schema.newProp = mon().validate('newProp must be odd', isOdd).fin();\n```\n\n### `prop.index(key|value, [value])`\n\nBind the key and value to the index attribute of the property. Providing only one parameter will set `index` equal to that parameter\n\n```javascript\n  schema.newProp = mon().index('unique', false).fin();\n  // or\n  schema.newProp = mon().index('hashed').fin();\n\n```\n\n\n\n\n\n\n\n\n\n\n\n# Types\n\n\n\n### `prop.string()`\n\nSet property type to `String`\n\n```javascript\n  schema.newProp = mon().string().fin();\n```\n\n### `prop.date()`\n\nSet property type to `Date`\n\n```javascript\n  schema.newProp = mon().date().fin();\n```\n\n### `prop.number()`\n\nSet property type to `Number`\n\n```javascript\n  schema.newProp = mon().number().fin();\n```\n\n### `prop.buffer()`\n\nSet property type to `Buffer`\n\n```javascript\n  schema.newProp = mon().buffer().fin();\n```\n\n### `prop.mixed()`\n\nSet property type to be mixed\n\n```javascript\n  schema.newProp = mon().mixed().fin();\n```\n\n### `prop.objectId()`\n\nSet property type to be an object ID\n\n```javascript\n  schema.newProp = mon().objectId().fin();\n```\n\n### `prop.array()`\n\nSet property type to be `Array`\n\n```javascript\n  schema.newProp = mon().array().fin();\n```\n\n### `prop.schema(ref, type)`\n\nSet property type to be a reference to another schema\n\n```ref```  -- Required - name of referred schema\n```type``` -- Optional - Defaults ```ObjectId```, possible values (```Number```, ```String```, ```Buffer```)\n\n```javascript\n  schema.newProp = mon().schema('schemaName').fin();\n```\n\n\n\n\n\n\n# Middleware\n\nAny time `[]` is a function parameter, its is optional.\n\n## Shared\n\n### `prop.onGet(function)`\n\ntype: any\n\nPasses the value of the property into the function. the returned value is what is exposed to the document on get\n\n```javascript\n  schema.newProp = mon().onGet(function (value) {\n    return value ? value + '-example' : value;\n  }).fin();\n```\n\n\n### `prop.onSet(function)`\n\ntype: any\n\nPasses the value of the property into the function. the returned value is what is saved to the document on get\n\n```javascript\n  schema.newProp = mon().onSet(function (value) {\n    return value ? value + '-example' : value;\n  }).fin();\n```\n\n\n\n\n## Date\n\n\n\n\n\n### `prop.expires(dateTime)`\n\ntype: date\n\nSets the expiration of the date\n\n```javascript\n  schema.newProp = mon().expires('1.5h').fin();\n```\n\n## String\n\n### `prop.toUppercase()`\n\ntype: string\n\nSets the value to uppercase\n\n```javascript\n  schema.newProp = mon().toUppercase().fin();\n```\n\n### `prop.toLowercase()`\n\ntype: string\n\nSets the value lowercase\n\n```javascript\n  schema.newProp = mon().toLowercase().fin();\n```\n\n### `prop.trim()`\n\ntype: string\n\nTrims the whitespace off the beginning and end of the string\n\n```javascript\n  schema.newProp = mon().trim().fin();\n```\n\n\n\n\n\n\n\n\n\n# Validation\n\n**important:** using validations that do not apply to the property type will throw an error. To allow them to pass silently, set mongo configuration `strict : false`.\n\nAny time `[]` is a function parameter, its is optional. any time `[message]` is included, a default message will be used unless this parameter is specified.\n\n\n\n\n## Shared\n\n\n\n\n### `prop.required()`\n\ntype: any\n\nreturn an error if the property is not defined\n\n```javascript\n  schema.newProp = mon().required().fin();\n```\n\n### `prop.default(value)`\n\ntype: any\n\nIf no value is set for the property, set it to the default value passed in\n\n```javascript\n  schema.newProp = mon().default('default value').fin();\n```\n\n### `prop.select([bool])`\n\ntype: any\n\n`[bool]` true or undefined if this path should always be included in the results, false if it should be excluded by default. This setting can be overridden at the query level.\n\n\n```javascript\n  schema.newProp = mon().select().fin();\n```\n\n### `prop.enum(values, [message])`\n\ntype: any\n\nIf the value submitted is not uncluded in the list of enumerated properties, an error is returned.\n\n```javascript\n  schema.newProp = mon().enum(['foo', 'bar'], 'custom error').fin();\n```\n\n### `prop.unique([bool])`\n\ntype: any\n\nInsures a unique index is generated for the property. defaults to true. False causes the DB to be indifferent\n\n```javascript\n  schema.newProp = mon().unique().fin();\n```\n\n### `prop.ref(model)`\n\ntype: any\n\nCreates a reference to another model. This is used to populate data from another document\n\n```javascript\n  schema.newProp = mon().objectId().ref('fooModel').fin();\n```\n\n### `prop.min(value, [message])`\n\ntype: `string` (length), `array` (length), `number` (value), `date` (value), `object` (keys), `buffer` (length)\n\nCheck that the value being saved is greater than or equal to the value passed into the property builder\n\n```javascript\n  schema.newProp = mon().min(5).fin();\n```\n\n### `prop.max(value, [message])`\n\ntype: `string` (length), `array` (length), `number` (value), `date` (value), `object` (keys), `buffer` (length)\n\nCheck that the value being saved is less than or equal to the value passed into the property builder\n\n```javascript\n  schema.newProp = mon().max(5).fin();\n```\n\n### `prop.length(value, [message])`\n\ntype: `string` (length), `array` (length), `object` (keys), `buffer` (length)\n\nCheck that the value being saved is the same length as the value passed into the property builder\n\n```javascript\n  schema.newProp = mon().length(5).fin();\n```\n\n\n\n\n## Arrays\n\n\n\n\n### `prop.sparse()`\n\nreturn an error if the array contains undefined values\n\n```javascript\n  schema.newProp = mon().array().sparse().fin();\n```\n\n\n\n\n## Strings\n\n\n\n\n\n### `prop.alphanum([message])`\n\nreturn an error if the string contains non alpha-numeric values\n\n```javascript\n  schema.newProp = mon().string().alphanum().fin();\n```\n\n### `prop.regex(expression, [message])`\n\nreturn an error if the string does not match the expression\n\n```javascript\n  schema.newProp = mon().string().regex(expression).fin();\n```\n\n### `prop.email([message])`\n\nreturn an error if the string is not a valid email address\n\n```javascript\n  schema.newProp = mon().string().email().fin();\n```\n\n### `prop.token([message])`\n\nreturn an error if the string is not a valid token\n\n```javascript\n  schema.newProp = mon().string().token().fin();\n```\n\n### `prop.guid([message])`\n\nreturn an error if the string is not a valid GUID\n\n```javascript\n  schema.newProp = mon().string().guid().fin();\n\n```\n\n### `prop.hostname([message])`\n\nreturn an error if the string is not a valid hostname\n\n```javascript\n  schema.newProp = mon().string().hostname().fin();\n\n```\n\n### `prop.url([message])`\n\nreturn an error if the string is not a valid url\n\n```javascript\n  schema.newProp = mon().string().url().fin();\n```\n\n### `prop.uppercase([message])`\n\nreturn an error if the string is not uppercase\n\n```javascript\n  schema.newProp = mon().string().uppercase().fin();\n```\n\n### `prop.lowercase([message])`\n\nreturn an error if the string is not lowercase\n\n```javascript\n  schema.newProp = mon().string().lowercase().fin();\n```\n\n\n\n\n## Numbers\n\n\n\n\n\n### `prop.greater(limit, [message])`\n\nreturn an error if the number is below the limit\n\n```javascript\n  schema.newProp = mon().number().greater(5).fin();\n```\n\n### `prop.less(limit, [message])`\n\nreturn an error if the number is above the limit\n\n```javascript\n  schema.newProp = mon().number().less(5).fin();\n```\n\n### `prop.integer([message])`\n\nreturn an error if the string is not an integer\n\n```javascript\n  schema.newProp = mon().string().integer().fin();\n```\n\n\n\n\n\n\n\n\n# Utilities\n\n\n\n\n\n\n\n\n### `mon.drop(collection)`\n\ndrop a collection by name (normally just 'db')\n\n```javascript\nmon.drop('db');\n```\n\n### `mon.connect([options])`\n\ntakes options, defaulting to 'mongodb://localhost/database'. returns an instance of the database. also accessable through `mon.db`\n\n```javascript\nvar db = mon.connect();\n```\n\n### `mon.schema(schema)`\n\nreturns an instance of a schema with the given schema object definition\n\n```javascript\nvar mySchema = mon.schema({\n  name : mon().string().required().fin()\n});\n```\n\n### `mon.model(modelName)`\n\nreturns the model matching the given name\n\n```javascript\nvar MyModel = mon.model('MyModel');\n```\n\n### `mon.new(modelName)`\n\nreturns a new instance of the model specified. applies the inputs if they are defined\n\n```javascript\nvar tester = mon.new('MyModel', {\n  name : 'tester'\n});\n```\n\n### `mon.register(schema, [options])`\n\nregisters a new model with the given schema and options. The options object is where middleware, methods, index properties, and virtual properties are defined. A minimalistic model is defined below\n\n```javascript\nvar mon    = require('mongoman');\nvar bcrypt = require('bcrypt-nodejs');\n\nmon.register('Person', {\n  firstName : mon().string().required().fin(),\n  lastName  : mon().string().required().fin(),\n  secret    : mon().string().fin()\n}, {\n  middleware : {\n    pre : {\n      save : function (callback) {\n        if (this.isModified('secret'))  {\n          this.secret = bcrypt.hashSync(this.secret, bcrypt.genSaltSync());\n        }\n\n        return callback();\n      }\n    }\n  },\n  methods : {\n    findFamily : function (callback) {\n      return mon.model('Person').find({\n        lastName : this.lastName\n      }, callback);\n    },\n    compareSecret : function(submitted, callback) {\n      var result = bcrypt.compareSync(submitted, this.secret);\n      return callback(null, result);\n    }\n  },\n  statics : {\n    findByFirst : function (first, callback) {\n      return mon.model('Person').find({\n        firstName : first\n      }, callback);\n    }\n  },\n  virtuals : {\n    fullName : {\n      get : function () {\n        return this.firstName + ' ' + this.lastName;\n      }\n    }\n  }\n});\n```\n\n### `mon.registerAll(directory, [regex])`\n\ntraverses the directory tree requiring all js files (to register models on server startup). optional regex to filter files\n\n**./models/foo.js**\n\n```javascript\nvar mon = require('mongoman');\nmon.register('foo', { foo : mon().string().fin() });\n```\n\n**./models/sub_models/bar_model.js**\n\n```javascript\nvar mon = require('mongoman');\nmon.register('bar', { bar : mon().string().fin() });\n```\n\n**./server.js**\n\n```javascript\n// ... server setup\n\nmon.connect();\n\nmon.registerAll('../models', /_model/); // registers ['bar']\n\n// OR\n\nmon.registerAll('../models'); // registers ['foo', 'bar']\n\n// ... server finalizing\n```\n\n\n\n\n\n\n\n\n\n# Running Unit Tests\n\nTo run the unit tests, execute the following:\n```\n  npm test\n```\n\nPlease make sure all unit tests pass before making a new PR\n\n",
  "readmeFilename": "README.md",
  "gitHead": "5b1b213b69d80a083282c46d9c252d3fe9446364",
  "bugs": {
    "url": "https://github.com/johnhof/mongoman/issues"
  },
  "homepage": "https://github.com/johnhof/mongoman",
  "_id": "mongoman@1.4.0",
  "_shasum": "d92071944e7b84a3b0fb5c2edc5b0f2a3e6e60fc",
  "_from": "mongoman@^1.0.0"
}
